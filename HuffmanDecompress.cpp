/* 
 * Decompression application using static Huffman coding
 * 
 * Usage: HuffmanDecompress InputFile OutputFile
 * This decompresses files generated by the "HuffmanCompress" application.
 * 
 * Copyright (c) Project Nayuki
 * 
 * https://www.nayuki.io/page/reference-huffman-coding
 * https://github.com/nayuki/Reference-Huffman-coding
 */

#include <boost/iostreams/device/mapped_file.hpp>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <limits>
#include <vector>
#include "BitIoStream.hpp"
#include "CanonicalCode.hpp"
#include "FrequencyTable.hpp"
#include "HuffmanCoder.hpp"

using std::uint32_t;
extern unsigned char* data1;
extern int ind;
std::vector<char> v2;

int main(int argc, char *argv[]) {
	// Handle command line arguments
	if (argc != 3) {
		std::cerr << "Usage: " << argv[0] << " InputFile OutputFile" << std::endl;
		return EXIT_FAILURE;
	}
	ind = 0;
	const char *inputFile  = argv[1];
	const char *outputFile = argv[2];
	
	// Perform file decompression
	boost::iostreams::mapped_file_source file;
	int numberOfBytes = 114041464;
	file.open(inputFile, numberOfBytes,0);
	data1 = (unsigned char *)file.data();

	std::ifstream in(inputFile, std::ios::binary);
	// std::ofstream out(outputFile, std::ios::binary);
	BitInputStream bin(in);
	try {
		
		// Read code length table
		std::vector<uint32_t> codeLengths;
		for (int i = 0; i < 257; i++) {
			// For this file format, we read 8 bits in big endian
			uint32_t val = 0;
			for (int j = 0; j < 8; j++)
				val = (val << 1) | bin.readNoEof();
			codeLengths.push_back(val);
		}
		const CanonicalCode canonCode(codeLengths);
		const CodeTree code = canonCode.toCodeTree();
		
		HuffmanDecoder dec(bin);
		dec.codeTree = &code;
		while (true) {
			uint32_t symbol = dec.read();
			if (symbol == 256)  // EOF symbol
				break;
			int b = static_cast<int>(symbol);
			if (std::numeric_limits<char>::is_signed)
				b -= (b >> 7) << 8;
			v2.push_back(static_cast<char>(b));
		}

		FILE* out1 = fopen(outputFile, "wb");
		fwrite(&v2[0], 1, v2.size(), out1);
		fclose(out1);

		return EXIT_SUCCESS;
		
	} catch (const char *msg) {
		std::cerr << msg << std::endl;
		return EXIT_FAILURE;
	}
}
